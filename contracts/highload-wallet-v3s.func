{-
  highload-wallet-v3s â€“ open-source optimized highload wallet for tvm-based blockchains (s - safest vesrion)

  Copyright (C) 2023 Continuation Team

  This file is part of highload-wallet-v3.

  highload-wallet-v3 is free software: you can redistribute it and/or modify it under the terms
  of the GNU Lesser General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  highload-wallet-v3 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License along with highload-wallet-v3.
  If not, see <https://www.gnu.org/licenses/>.
-}

#include "imports/stdlib.fc";
#include "auto/timeout.func";


;;; Store binary true b{1} to `builder` [b]
builder store_true(builder b) asm "STONE";

;;; Store `cell` [actions] to register c5 (out actions)
() set_actions(cell actions) impure asm "c5 POP";

;; load msg_flags only
(slice, int) ~load_msg_flags(slice s) asm(-> 1 0) "4 LDU";

;;; Checking that the "bounced" bit in the flags is set to "true"
int bounced?(int flags) asm "ONE AND";

builder store_zeroes(builder b, int x) asm "STZEROES";
(slice, int) internal_transfer?(slice s) asm "x{ae42e5a4} SDBEGINSQ";
(slice, ()) ~skip_query_id(slice s) asm "64 LDU NIP";
(slice, ()) ~skip_ref(slice s) asm "LDREF NIP";
(slice, ()) ~skip_coins(slice s) asm "LDGRAMS NIP";
(slice, ()) ~skip_msg_addr(slice s) asm "LDMSGADDR NIP";
(slice, ()) ~skip_zero(slice s) asm "b{0} SDBEGINS";
(slice, ()) ~skip_dict(slice s) asm "SKIPOPTREF";


() recv_internal(cell in_msg_full, slice in_msg_body) {
  (int body_bits, int body_refs) = in_msg_body.slice_bits_refs();
  ifnot ((body_refs == 1) & (body_bits == (32 + 64))) {
    return ();
  }

  slice in_msg_full_slice = in_msg_full.begin_parse();
  int flags = in_msg_full_slice~load_msg_flags();
  slice sender = in_msg_full_slice~load_msg_addr();

  if ((~ sender.equal_slice_bits(my_address())) | (flags.bounced?())) {
    return ();
  }

  if (in_msg_body~internal_transfer?()) {
    in_msg_body~skip_query_id();
    cell actions = in_msg_body.preload_ref();
    set_actions(actions);
    return ();
  }
}


() recv_external(slice msg_body) {
  cell  msg_inner     = msg_body~load_ref();
  slice sign          = msg_body~load_bits(512);
  msg_body.end_parse();
  int   hash          = msg_inner.cell_hash();

  slice ds            = get_data().begin_parse();
  int   pubkey        = ds~load_uint(256);
  int   subwallet_id  = ds~load_uint(32);
  cell  old_queries   = ds~load_dict();
  cell  queries       = ds~load_dict();
  int   last_cleaned  = ds.preload_uint(40);

  if (last_cleaned < (now() - TIMEOUT)) {
    (old_queries, queries) = (queries, null());
    if (last_cleaned < (now() - (TIMEOUT * 2))) {
      old_queries = null();
    }
    last_cleaned = now();
  }

  throw_unless(33, check_signature(hash, sign, pubkey));

  slice cs            = msg_inner.begin_parse();
  cell  message       = cs~load_ref();
  int   mode          = cs~load_uint(8);
  int   shift         = cs~load_uint(14);
  int   bit_number    = cs~load_uint(10);
  int   created_at    = cs~load_uint(40);
  int   _subwallet_id = cs~load_uint(32);
  cs.end_parse();

  throw_unless(34, _subwallet_id == subwallet_id);

  throw_unless(35, created_at == min(now(), max(created_at, now() - TIMEOUT)));

  (cell value, int f) = old_queries.udict_get_ref?(14, shift);
  if (f) {
    slice vs = value.begin_parse();
    vs~skip_bits(bit_number);
    throw_if(36, vs.preload_int(1));
  }

  (cell value, int f) = queries.udict_get_ref?(14, shift);
  builder new_value = begin_cell();
  if (f) {
    slice vs = value.begin_parse();
    (slice vs_tail, slice vs_head) = vs.load_bits(bit_number);
    throw_if(36, vs_tail~load_int(1));
    new_value = begin_cell().store_slice(vs_head).store_true().store_slice(vs_tail);
  } else {
    new_value = begin_cell().store_zeroes(bit_number).store_true().store_zeroes(1023 - bit_number - 1);
  }

  accept_message();

  queries~udict_set_ref(14, shift, new_value.end_cell());

  set_data(begin_cell()
          .store_uint(pubkey, 256)
          .store_uint(subwallet_id, 32)
          .store_dict(old_queries)
          .store_dict(queries)
          .store_uint(last_cleaned, 40)
          .end_cell());


  commit();

  slice message_slice = message.begin_parse();
  {-
    extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32))
               = ExtraCurrencyCollection;
    currencies$_ grams:Grams other:ExtraCurrencyCollection
               = CurrencyCollection;

    int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
      src:MsgAddressInt dest:MsgAddressInt
      value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
      created_lt:uint64 created_at:uint32 = CommonMsgInfo;

    message$_ {X:Type} info:CommonMsgInfo
      init:(Maybe (Either StateInit ^StateInit))
      body:(Either X ^X) = Message X;
  -}

  message_slice~skip_zero(); ;; throw if not int_msg_info$0
  int flags = message_slice~load_uint(3);
  if (flags.bounced?()) { return (); }
  message_slice~skip_msg_addr();
  message_slice~skip_msg_addr();
  message_slice~skip_coins();
  message_slice~skip_dict();
  message_slice~skip_coins();
  message_slice~skip_coins();
  message_slice~skip_bits(64 + 32);
  message_slice~skip_zero(); ;; throw if state-init included (state-init not supported)
  int either_body = message_slice~load_int(1);
  if (either_body) {
    message_slice~skip_ref();
    message_slice.end_parse();
  }

  send_raw_message(message, mode | 2);
}


int get_public_key() method_id {
  return get_data().begin_parse().preload_uint(256);
}


int get_subwallet_id() method_id {
  slice ds = get_data().begin_parse();
  ds~skip_bits(256);
  return ds.preload_uint(32);
}

int get_last_cleaned() method_id {
  slice ds = get_data().begin_parse();
  ds~skip_bits(256 + 32 + 1 + 1);
  return ds.preload_uint(40);
}

int get_timeout() method_id {
  return TIMEOUT;
}

int processed?(int query_id) method_id {
  int shift      = query_id >> 10;
  int bit_number = query_id & 1023;

  slice ds          = get_data().begin_parse();
  ds~skip_bits(256 + 32);
  cell  old_queries = ds~load_dict();
  cell  queries     = ds~load_dict();

  (cell value, int f) = old_queries.udict_get_ref?(14, shift);
  if (f) {
    slice vs = value.begin_parse();
    vs~skip_bits(bit_number);
    if (vs.preload_int(1)) {
      return -1;
    }
  }

  (cell value, int f) = queries.udict_get_ref?(14, shift);
  if (f) {
    slice vs = value.begin_parse();
    vs~skip_bits(bit_number);
    if (vs.preload_int(1)) {
      return -1;
    }
  }

  return 0;
}